[{"content":"第一讲 计算机基本结构（Basic Components of a Computer）  内容要点：冯·诺伊曼结构，计算机执行指令的过程\n 1.1 电子计算机的兴起——“现代电子计算机之父”冯·诺依曼  1939年，艾奥瓦州立大学，约翰·阿塔纳索夫、克利夫·贝里，ABC计算机 1946年2月14日，美国宾夕法尼亚大学，约翰·莫克利、约翰·埃克特，世界上第一台通用电子计算机ENIAC （Electronic Numerical Integrator And Computer，电子数字积分器和机算器，18000个电子管、十进制、每秒5000次加法、150千瓦、170平方米、30吨、50万美元）  冯·诺依曼对ENIAC的分析：ENIAC的开关定位和转插线只不过代表着一些数字信息，完全可以像受程序管理的数据一样，存放于主存储器中。（“存储程序”的概念） 1945年6月30日，冯·诺依曼《关于EDVAC的报告草案》（美国陆军军械部-宾夕法尼亚大学摩尔电机工程学院）：该报告所描述的计算机结构，即为“冯·诺依曼计算机结构”  1949年5月6日，英国剑桥大学数学实验室，莫里斯·威尔克斯，以EDVAC为蓝本设计和建造的EDSAC（Electronic Delay Storage Automatic Calculator，电子延迟储存自动计算机）：第一台实用的储存程序式计算机  五个组成部分：  运算器和控制器：电子管 存储器：水银延迟线 输入设备：从穿孔纸带输入 输出设备：电传打印机     1949年8月交付的EDVAC （Electronic Discrete Variable Automatic Computer，离散变量电子计算机） 的主要特点：  实现“存储程序”概念，大幅提升了任务效率 指令和数据采用二进制，极大简化了逻辑线路 由五个基本部分组成：运算器，控制器，存储器、输入设备，输出设备   1951年，计开始于埃克特-莫克利计算机公司（EMCC）完成于雷明顿·兰德公司（Remington Rand）的UNIVAC （UNIVersal Automatic Computer，每秒10万次加法，主频2.25MHz） 交付美国人口普查局  1952年，UNIVAC统计选票率先准确预测艾森·豪威尔赢得选举，因此和电子计算机获得了广泛的关注 UNIVAC：开启了商用计算机的时代  1950年代，众多公司进入电子计算机领域 1953年，IBM成功转型，推出大型计算机IBM701 1955年，IBM占领了70％的市场（“IBM和七个小矮人”：Burroughs，Sperry Rand(UNIVAC)， CDC，Honeywell，GE，RCA，NCR）          1.2 冯·诺依曼结构的要点   冯·诺依曼和《关于EDVAC的报告草案》\n 长度101页，未完成稿 论述了两个重要设计思想  存储程序（而不是开关连线） 二进制（而不是十进制：导致计算机内部结构异常复杂）   明确了计算机的五个部分：运算器、控制器、储存器、输入设备、输出设备    1971年，世界上第一个商业微处理器Intel 4004\n  面积：4.2mmx3.2mm\n  制造工艺：10微米\n  晶体管数量：2250\n  主频：最高740KHz，性能与ENIAC相当\n  字长：4位\n  1971年最初用于计算器Busicom 141-PF\n MCS-4（Micro Computer Set）芯片组               冯·诺依曼结构的要点\n  计算机的五大组成部分\n 运算器，CA：central arithmetical 控制器，CC：central control 存储器，M：memory 输入设备，I：input 输出设备，O：output    数据和程序均以二进制代码形式不加区别地存放在存储器中，存放位置由存储器的地址指定\n  冯·诺依曼结构的核心\n   冯·诺依曼结构 现代计算机     运算器CA和控制器CC，合称C CPU（Central Processing Unit）   存储器M 主存储器（主存、内存）     主存的组织形式：地址（二进制，每个储存单元对应的序号）+内容（二进制，储存单元中存放的信息，1个存储单元1个字节/8位）      计算机在工作时能够自动地从存储器中取出指令加以执行\n 执行指令：计算机运转的核心内容  主要步骤：取指（Fetch）→译码（Decode）→执行（Execute）→回写（Write-back）        1.3 计算机结构的简化模型（模型机）  存储器  存储单元的位宽：由编址方法确定（按字节编址，每个储存单元存放8位二进制数） 存储单元的地址：唯一的，不同存储单元地址互不相同 地址总线：宽度为$n$，CPU能管理的存储单元最多$2^n$个（32位宽地址总线，内存最多4G）  MAR：Memory Address Register，用于存放CPU正在读或写的存储单元的地址   数据总线：宽度一般为存储单元位宽的整数倍  MDR：Memory Data Register，用于存放CPU正在读出或即将写入存储单元的数据   控制总线：传输读、写、完成等控制信号   CPU  控制器：用于控制计算机各部件完成取指令、分析指令和执行指令等功能  指令寄存器IR：Instruction Register，存放正在执行或者即将执行的指令 程序计数器PC：Program Counter：存放下一条指令的存储单元地址，具有自动增量计数的功能 存储器地址寄存器MAR：Memory Address Register，在访存时用于存放存储单元的地址 存储器数据寄存器MDR：Memory Data Register，在访存时用于存放对存储单元读/写的数据 指令译码部件：对IR中的指令进行译码，已确定IR中存放的是哪一条指令 控制电路：产生控制信号，在时序脉冲的同步下控制各个部件的动作   运算器：用于算术运算和逻辑运算（常见算术运算：加、减、乘、除等；常见逻辑运算：非、与、或等）  ALU：算术逻辑单元，核心部件，用于完成算术运算和逻辑运算  ALU对X、Y中的数据进行运算，将结果送到Z。X、Y、Z作为ALU的数据暂存器，可视为ALU的一部分   F：标志寄存器，用于存放运算结果的状态（零/正负/进位/溢出） $R_0$~$R_{n-1}$：n个通用寄存器，用于临时存放数据。数据可能来自存储器，也可能来自其他通用寄存器或ALU的输出   内部总线：在CPU各个部件之间传递数据    1.4 计算机执行指令的过程   执行指令的示例\n  指令格式：ADD $R_0$, [6]\n  指令功能：通用寄存器$R_0$的内容+地址为6的储存单元的内容=运算结果\n　↑更新_↓\n  假设模型机当前状态：\n  执行过程：\n  取指\n  控制器将指令的地址送往存储器：控制器发出控制信号将PC寄存器中的内容通过内部总线传送到MAR中（MAR寄存器：0001）→MAR将这个地址送到地址总线上，控制电路同时在控制总线上发出读操作的控制信号→存储器的MAR寄存器收到地址总线上传送来的地址并保存，存储器中的控制逻辑收到控制总线中传送来的读操作控制信号\n  存储器按给定的地址读出指令内容，送回控制器：存储器通过地址译码器 查找到对应地址001的存储单元的内容，并将该存储单元的内容送到MDR寄存器中→存储器的控制逻辑通过控制总线向CPU反馈当前的传输已经准备好了， 同时MDR中的内容送数据总线上→CPU中的控制电路检测到来自控制总线的准备好的ready信号，MDR寄存器就会将当前数据总线上传送来的数值保存下来→MDR将内容传送到IR寄存器→更新PC寄存器为下一条指令的地址\n    译码\n  控制器分析指令的操作性质：IR寄存器将指令编码送至指令译码部件\n  控制器向有关部件发出指令所需的控制信号：译码部件翻译出指令后，控制电路产生相应的控制信号，发送到相关部件中\n    执行\n  控制器从通用寄存器或存储器取出操作数：控制器在MAR中放置要访问的存储器的地址0110，进行类似于取指阶段的操作→控制器将MDR中的数据暂存到Y寄存器中→控制器将$R_0$的数据传送到X寄存器中\n  控制器命令运算器对操作数进行指令规定的运算：控制电路命令ALU将X、Y中的内容执行加法并计算出结果\n    回写：控制电路发出控制信号将Z寄存器当中的内容传送到$R_0$中，覆盖原来的内容\n  继续执行下一条指令\n      1.5 计算机输入和输出   外部记录介质，R：outside recording medium\n  模型机上的输入输出设备\n  现代个人计算机的输入输出\n  南桥芯片内部包含磁盘键盘、鼠标、音频、网络和USB等多种输入输出设备或接口的控制器\n 南北桥的演变  传统来说，主板上两个主要芯片，靠上方的叫北桥，靠下方的叫南桥。\n大体上说：北桥负责与CPU通信，并且连接高速设备（内存/显卡），并且与南桥通信；南桥负责与低速设备（硬盘/USB）通信，时钟/BIOS/系统管理/旧式设备控制，并且与北桥通信。\nIntel从第一代Core i7 (i7 9xx)开始，将原属于北桥功能的内存控制器整合到CPU当中，在主流机Core i中(i7 8xx)更将PCI-e控制器（主要负责连接显卡）整合到CPU当中，这时候传统意义上的北桥的所有功能都已经整合到CPU内部了，所以Intel 50系芯片“组”（X58除外，这是搭配i7 9xx用的，还有北桥）已经没有传统意义的北桥了，而南桥依然负责处理低速设备（SATA/USB/PCI等）、时钟等功能。由于只剩下一个芯片了，也没有“芯片组”的说法了，只剩下孤零零的PCH (Platform Controller Hub)。\nAMD平台的发展轨迹类似，在K8架构（第一代AMD64处理器）开始就把内存控制器集成到CPU内部，后来先是APU再是桌面的FX系列，陆陆续续把PCI-e控制器也整合到CPU中，也剩下孤零零的FCH (Fusion Controller Hub)……\n于是这两家的南桥（PCH/FCH）现在差不多变成了一个PCI-e Hub了……\n    部分性能要求高或者用途特殊的输入输出接口采用独立芯片或板卡的形式\n    1.6 冯·诺依曼结构的具体实现   南北桥架构的演变\n    →  →       系统芯片 System-on-a-Chip，SoC：将计算机或其他电子系统集成为单一芯片的集成电路\n          第二讲 指令系统体系结构（Instruction Set Architecture）  内容要点：x86 ISA，MIPS ISA\n 2.1 设计自己的计算机   一个简单的计算机指令系统\n   指令类别 指令     运算类指令 ADD R, M 功能：将R的内容与M中的内容相加后存入R   传送类指令 LOAD R,M 功能：将M中的内容装入RSTORE M, R 功能：将R的内容存入M中   转移类指令 JMP L 功能：无条件转向L处    注：M和L为存储器地址，R为寄存器编号\n  指令的格式\n 每条指令等长，均为2个字节 第一个字节的高4位是操作码  LOAD: 0000; ADD: 0001 STORE: 0010; JMP: 0011 目前只提供4条指令，最多可扩展到16条   第一个字节的低4位是寄存器号  $R_0\\textasciitilde R_3$O: 0000~0011目 前只提供4个寄存器，最多可扩展到16个   第二个字节是存储单元地址  最大可以使用256个字节的存储器      2.2 x86体系结构   Intel 8086（1978年）\n  内部的通用寄存器为16位，既能处理16位数据，也能处理8位数据\n  8086的寄存器模型\n  通用寄存器（多功能寄存器）\n  数据寄存器，共有4个，均为16位寄存器\n  每个16位寄存器都可分为两个8位寄存器使用\n  适用大多数算术运算和逻辑运算指令\n  除存放通用数据外，各有一些专门的用途：\n   AX Accumulator 存放乘除等指令的操作数     BX Base 存放存储单元的偏移地址   CX Count 存放计数值   DX Data 乘法运算产生的部分积 除法运算的部分被除数        标志寄存器：标志位\n  FLAGS寄存器中包含若干标志位\n  标志位分为两大类：状态标志和控制标志\n 状态标志：反映CPU的工作状态  例如：执行加法运算时是否产生进位；运算结果是否为零   控制标志：对CPU的运行起特定控制作用  例如：以单步方式还是连续方式运行；是否允许响应外部中断请求        指令指针寄存器 IP（Instruction Pointer）：保存一个内存地址，指向当前需要取出的指令\n 当CPU从内存中取出一个指令后，IP会自动增加，指向下一指令的地址（注：实际情况会复杂的多） 程序员不能直接对IP进行存取操作 转移指令、过程调用/返回指令等会改变IP的内容 IP寄存器的寻址能力：$2^{16}=65536$（64K）字节单元8 8086对外有20位地址线，寻址范围：$2^{20}=1M$字节单元    段寄存器 Segment Register：与其它寄存器联合生成存储器地址\n CS代码段寄存器 Code Segment DS数据段寄存器 Data Segment ES附加段寄存器 Extra Segment SS堆栈段寄存器 Stack Segment    8086的物理地址生成\n      对外有16根数据线和20根地址线可寻址的内存空间为1MByte（220）\n  物理地址的形成采用段加偏移的方式\n    Intel 80386（1985年） 主频12.5~33MHz、27.5万个晶体管\n  80x86系列中的第一款32位微处理器\n  支持32位的算术和逻辑运算，提供32位的通用寄存器\n  地址总线扩展到32位，可寻址4GB的内存空间\n  改进了“保护模式”（例如，段范围可达4GB）\n  增加了“虚拟8086模式”，可以同时模拟多个8086微处理器\n  IA-32的寄存器模型\n注：保护模式下，段寄存器有不同的使用方法\n    Intel IA-64：独立于x86，不兼容IA-32，并未获得成功\n  x86-64（2003年）\n  2.3 x86指令简介  指令的主要类别    指令的运行结果\n 改变通用寄存器的内容 改变存储器单元的内容 改变标志位 改变指令指针 改变外设端口的内容 其他    程序示例\n  传送指令：把数据或地址传送到寄存器或存储器单元中\n   分组 助记符 功能 操作数类型     通用数据传送指令 MOV 传送 字节/字    PUSH 压栈 字    POP 弹栈 字    XCHG 交换 字节/字   累加器专用传送指令 XLAT 换码 字节    IN 输入 字节/字    OUT 输出 字节/字   地址传送指令 LEA 装入有效地址 字    LDS 把指针装入寄存器和DS 4个字节    LES 把指针装入寄存器和ES 4个字节   标志传送指令 LAHF 把标志装入AH 字节    SAHF 把AH送标志寄存器 字节    PUSHF 标志压栈 字    POPF 标志弹栈 字      MOV指令\n  格式：MOV DST, SRC\n  操作：DST←SRC，把一个操作数从源传送至目的，源操作数保持不变\n  寻址方式示例\n  编码示例：变长指令\n      运算指令\n  逻辑运算和移位指令/位操作指令：实现对二进制位的操作和控制\n   分组 助记符 功能     逻辑运算 NOT 逻辑非    AND 逻辑与    OR 逻辑或    XOR 逻辑异或    TEST 逻辑测试   移位 SHL 逻辑左移    SAL 算术左移    SHR 逻辑右移    SAR 算术右移   循环移位 ROL 循环左移    ROR 循环右移    RCL 带进位循环左移    RCR 带进位循环右移     操作数的限制  对于单操作数指令，操作数不能是立即数 对于双操作数指令，限制与MOV指令相同      算术运算指令：完成加、减、乘、除等算术运算，提供运算结果调整、符号扩展等功能\n   分组 助记符 功能     加法 ADD 加    ADC 加（带进位）    INC 加1   减法 SUB 减    SBB 减（带借位）    DEC 减1    NEG 取补    CMP 比较   乘法 MUL 乘（不带符号）    IMUL 乘（带符号）   除法 DIV 除（不带符号）    IDIV 除（带符号）      操作数的限制\n 目的操作数不能是立即数或CS寄存器 两个操作数不能同时为存储器操作数    加法类指令\n1 2 3 4 5 6 7 8  ADD BL, 8 ADD WORD PTR[BX], DX ADD EAX, ECX ADC EBX, EDX ;EBX:EAX+EDX:ECX INC CL     ADD指令（加）\n 格式：ADD DST, SRC 操作：DST←DST+SRC    ADC指令（带进位的加）\n 格式：ADC DST, SRC 操作：DST←DST+SRC+CF    INC指令（加1）\n 格式：INC OPR 操作：OPR←OPR+1          转移指令：改变指令执行顺序\n  根据是否有判断条件，分为无条件转移指令和条件转移指令两大类\n  根据转移目标地址的提供方式，可分为直接转移和间接转移两种方式\n    直接转移 间接转移     无条件转移指令     条件转移指令       条件转移指令：根据某一状态标志转移    分组 格式 功能 测试条件     根据某一状态标志转移 JC LABEL 有进位时转移 CF=1    JNC LABEL 无进位时转移 CF=0    JP/JPE LABEL 奇偶位为1时转移 PF=1    JNP/JPO LABEL 奇偶位为0时转移 PF=0    JZ/JE LABEL 为零/相等时转移 ZF=1    JNZ/JNE LABEL 不为零/不相等时转移 ZF=0    JS LABEL 负数时转移 SF=1    JNS LABEL 正数时转移 SF=0    JO LABEL 溢出时转移 OF=1    JNO LABEL 无溢出时转移 OF=0   对无符号数 JB/JNAE LABEL 低于/不高于等于时转移 CF=1    JNB/JAE LABEL 不低于高于等于时转移 CF=0    JA/JNBE LABEL 高于/不低于等于时转移 CF=0且ZF=0    JNA/JBE LABEL 不高于/低于等于时转移 CF=1或ZF=1   对有符号数 JL/JNGE LABEL 小于/不大于等于时转移 SF≠OF    JNL/JGE LABEL 不小于/大于等于时转移 SF=OF    JG/JNLE LABEL 大于/不小于等于时转移 ZF=0且SF=OF    JNG/JLE LABEL 不大于/小于等于时转移 ZF=1或SF≠OF          控制指令：控制CPU的功能；对标志位进行操作\n   分组 格式 功能     标志操作指令 STC 把进位标志CF置1    CLC 把进位标志CF清0    CMC 把进位标志CF取反    STD 把方向标志DF置1    CLD DF清0把方向标志    STI 把中断标志IF置1    CLI 把中断标志IF清0   外同步指令 HLT 暂停    WAIT 等待    ESC 交权    LOCK 封锁总线（指令前缀）   空操作 NOP 空操作        2.4 复杂的x86指令举例   串操作\n   分组 助记符 功能     串操作指令 MOVS (MOVSB, MOVSW) 串传送（字节串传送，字串传送）    CMPS (CMPSB, CMPSW) 串比较（字节串比较，字串比较）    SCAS (SCASB, SCASW) 串扫描（字节串扫描，字串扫描）    LODS (LODSB, LODSW) 取串（取字节串，取字串）    STOS (STOSB, STOSW) 存串（存字节串，存字串）   重复前缀 REP 无条件重复前缀    REPE/REPZ 相等/为零重复前缀    REPNE/REPNZ 不相等/不为零重复前缀      作用\n 对存储器中的数据串进行每次一个元素的操作 串的基本单位是字节或字（即“一个元素”） 串长度可达64KB    分类\n  共5条串操作指令\n  MOVSB指令（字节串传送）\n  格式：MOVSB\n  操作：在存储器中将指定位置的一个字节单元传送到另一个指定的位置\n  隐含操作数\n 源串地址为DS:SI，目的串地址为ES:DI 串的长度在CX寄存器中    处理完一个串元素后的操作（硬件自动完成）\n 修改SI和DI，指向下一个串元素 若使用重复前，则CX←CX-1    串传送方向（DF标志位）：应对源串和“目的串的存储区域部分重叠的问题\n 设置DF=0  从“源串”的低地址开始传送 传送过程中，SI和DI自动增量修改   设置DF=1  从“源串”的高地址开始传送 传送过程中，SI和DI自动减量修改          另有3种重复前缀，与串操作指令配合使用\n REP前缀（无条件重复）  格式：REP 串操作指令 操作：当CX≠0时，重复执行串操作指令          “最长的指令”\n1  LOCK ADD DWORD PTR ES:[EAX+ECX*8+11223344H], 12345678H   指令编码：26 66 67 F0 81 84 C8 44 33 22 11 78 56 34 12（15个字节）\n  2.5 MIPS体系结构   MIPS指令的发展\n  MIPS的设计指导思想\n Microprocessor without Interlocked Piped Stages 主要关注点  减少指令的类型 降低指令复杂度   基本原则： A simpler CPU is a faster CPU    主要特点\n 固定的指令长度：32-bit，即1word👉简化了从存储器取指令 简单的寻址模式👉简化了从存储器取操作数 指令数量少，指令功能简单（一条指令只完成一个操作）👉简化指令的执行过程 只有Load和Store指令可以访问存储器👉例如，不支持x86指令的这种操作：ADD AX, [3000H] 需要优秀的编译器支持    MIPS指令示例\n  运算指令\n 算术运算  加法指令  格式：add a, b, c 操作：将b和c求和，结果放入a中   sub a, b, c mul a, b, c div a, b, c   逻辑运算  and a, b, c or a, b, c   移位  sll a, b, c srl a, b, c      访存指令\n 假设\n A是一个100个字（word）的数组，首地址在寄存器$19中 变量h对应寄存器$18 临时数据存放在寄存器$8  A[10] = h + A[3]对应的MIPS指令为\n1 2 3  lw $18, 12($19) # t0 = A[3], 12表示位移 (MIPS中一个字32位) add $8, $18, $8 # t0 = h + A[3] sw $8, 40($19) # A[10] = h + A[3]        MIPS的通用寄存器：32个，每个都是32位宽\n   编号 名称 用途     0 $zero The Constant Value 0   1 $at Assembler Temporary   2-3 $v0-$v1 Values for Function Results and Expression Evaluation   4-7 $a0-$a3 Arguments   8-15 $t0-$t7 Temporaries   16-23* $s0-$s7 Saved Temporaries   24-25 $t8-$t9 Temporaries   26-27 $k0-$k1 Reserved for OS Kernel   28* $gp Global Pointer   29* $sp Stack Pointer   30* $fp Frame Pointer   31* $ra Return Address    * Preserved across a call\n  2.6 MIPS指令简介  MIPS Green Sheet            MIPS指令的基本格式\n* R：Register，寄存器；I：Immediate，立即数；J：Jump，无条件转移\n    R型指令 I型指令 J型指令     运算指令 add rd, rs, rt\nsll rd, rt, shamt addi rt, rs, imm\nslti rt, rs, imm /   访存指令 / lw rt, imm(rs)\nsw rt, imm(rs) /   分支指令 jr rs beq rs, rt, imm j addr      R型指令的格式：包含六个域\n 2个6-bit域，可表示0~63  opcode：用于指定指令的类型，所有R型指令该域值均为0 funct：与opcode域组合，精确地指定指令的类型   4个5-bit域，可表示0~31，对应32个通用寄存器  rs：Source Register，通常用于指定第一个源操作数所在的寄存器编号 rt：Target Register，通常用于指定第二个源操作数所在的寄存器编号 rd：Destination Register，通常用于指定日的操作数（保存运算结果）的寄存器编号 shamt：shift amount，用于移位指令进行移位操作的位数；非移位指令该域均为0   示例：add $8, $9, $10（opcode=0，funct=32，shamt=0，rd=8，rs=9，rt=10）→000000 01001 01010 01000 00000 100000    I型指令的格式\n immediate域：16-bit的立即数，可以表示$2^{16}$个不同数值  对于访存指令，通常可以满足访存地址偏移量的需求（-32768~+32767） 对于运算指令，无法满足全部需求   示例：addi $21, $22, -50 # $21 = $22 + (-50)（opcode=8，rs=22，rt=21，immediate=-50）→001000 10110 10101 1111 1111 1100 1110    分支指令：改变控制流\n  条件分支（I型）：根据比较的结果改变控制流\n  beq：branch if equal\n 格式：beq reg1, reg2, L1（opcode=4） 操作：if (value in reg1) == (value in reg2) goto L1    bne：branch if not equal\n bne rs, rt, imm（opcode=5）    示例\n1 2 3 4  if (i == j) f = g + h; else f = g - h;   1 2 3 4 5 6  beq $s3, $s4, True # branch i == j sub $s0, $s1, $s2 # f = g - h (false) j Fin # goto Fin True: add $s0, $s1, $s2 # f = g + h (true) Fin: ...     目标地址范围\n 以当前PC为基准，16-bit位移量可以表示$±2^{15}$bytes MIPS的指令长度固定为32-bit（word）：指令位置一定在四个字节对齐处，指令地址低两位必为0 16-bit位移量可以表示$±2^{15}$words = $±2^{17}$bytes ($±128$KB)    目标地址计算方法\n 分支条件不成立，PC = PC + 4 = next instruction 分支条件成立PC = (PC + 4) + (immediate * 4)      非条件分支：无条件地改变控制流\n j（J型）：jump  目标地址范围：$±2^{28}$bytes（$±256$MB） 目标地址计算方法：New PC = {(PC + 4) [31..28], address, 00}   jr（R型）：jump register  格式：jr rs          第三讲 算术逻辑单元（Arithmetic Logic Unit）  内容要点：逻辑运算，二进制加减法运算，ALU的实现\n 3.1 算术运算和逻辑运算   算术运算指令 MIPS Core Instruction Set\n  R型\n add rd, rs, rt #R[rd] = R[rs] + R[rt] (1) addu rd, rs, rt # R[rd] = R[rs] + R[rt] sub rd, rs, rt # R[rd] = R[rs] - R[rt] (1) subu rd, rs, rt # R[rd] = R[rs] - R[rt]  (1) May cause overflow exception\n  I型\n addi rt, ts, imm # R[rt] = R[rs] + SignExtImm (1, 2) addiu rt, rs, imm # R[rt] = R[rs] +SignExtImm (2)  (1) May cause overflow exception\n(2) SignExtImm = {16{imm[15]}, imm}（符号扩展）\n    逻辑运算指令 MIPS Core Instruction Set\n  R型\n and rd, rs, rt # R[rd] = R[rs] \u0026amp; R[rt] or rd, rs, rt # R[rd] = R[rs] | R[rt] nor rd, rs, rt # R[rd] = ~ (R[rs] | R[rt])    I型\n andi rt, rs, imm # R[rt] = R[rs] \u0026amp; ZeroExtImm (3) ori rt, rs, imm # R[rt] = R[rs] | ZeroExtImm (3)  (3) ZeroExtImm = {16{1'b0}, imm}（零扩展）\n    算术逻辑运算的需求\n 算术运算  两个32—bit数的加法，结果为一个32-bit数 两个32-bit数的减法，结果为一个32-bit数 检查加减法的结果是否溢出   逻辑运算  两个32-bit数的“与”操作，结果为一个32-bit数 两个32-bit数的“或”操作，结果为一个32-bit数 两个32-bit数的“或非”操作，结果为一个32-bit数      3.2 门电路的基本原理   晶体管 transistor：现代集成电路中通常使用MOS晶体管（Metal-Oxide-Semiconductor：金属-氧化物-半导体）\n    N型MOS管 P型MIS管     电路图     导通条件 Gate端连接高电平 Gate端连接低电平      CMOS集成电路 Complementary MOS：由PMOS和NMOS共同构成的互补型MOS集成电路\n  门电路的实现\n    非门 NOT gate 与门 AND gate 与非门 NAND gate 或门 OR gate 异或门 Exclusive-OR gate / XOR gate     逻辑符号        真值表        逻辑函数表示 $Y=\\bar{A}$（$Y=\\sim{A}$，$Y=!A$） $Y=A\\cdot B$ $Y=\\overline{AB}=\\overline{A\\cdot B}=A\\bar{\\wedge}B=\\overline{A\\wedge B}$ $Y=A+B$ $Y=A\\otimes B=(\\bar{A}\\cdot B)+(A\\cdot\\bar{B})$（$Y=A \\char`^B$）   工作过程  （实际用“与非门”和“非门”实现“与门”)         3.3 寄存器的基本原理   寄存器的内部结构\n 32个D触发器：仅为原理性说明    D触发器 D flip-flop / DFF\n  具有存储信息能力的基本单元\n  由若干逻辑门构成，有多种实现方式\n  主要有一个数据输入、一个数据输出和一个时钟输入\n  在时钟clock的上升沿（0→1，低电平→高电平），经过clock to Q的时间，采样输入D的值，传送到输出Q，其余时间输出Q的值不变\n 时钟频率（如约定每十秒钟会来按一次快门→时钟频率0.1Hz） 要求输入信号在时钟上升沿之前有一段很短的稳定时间（set up时间），在时钟上升沿之后也需要有一段很短的稳定时间（hold时间）：对于D触发器来说，在时钟上升沿前后很短的时间内，输入端的信号不能发生变化，否则就可能造成无法正确的采样 在一个复杂的系统中有很多的D触发器用各种不同的方式相连，就可以在不同的触发器中存放不同的信息， 并在时钟的控制下进行传递，而在时钟上升沿没有到来的时候， 无论输入发生什么样的变化都不会影响到后面触发器的输出    时序图\n时钟周期：两个上升沿之间的间隔时间\n      3.4 逻辑运算的实现   与运算的实现：and rd, ts, r\n  或运算的实现：or rd, ts, r\n  包含多种功能的运算单元：假设四种运算类型\n  逻辑运算示例\n    3.5 加法和减法的实现   二进制的加法\n    两个4-bit二进制数相加：\n1. 两个1-bit二进制数相加\n2. 进位参与输入运算\n3. 可以产生进位输出      半加器 Half Adder：将两个一位二进制数相加\n   A B C S     0 0 0 0   0 1 0 1   1 0 0 1   1 1 1 0     输入端口A、B 输出端口S（和）、C（进位） 不能将低位产生的进位作为输入参与运算    全加器 Full Adder：由两个半加器构成\n   A B $C_{in}$ $C_{out}$ S     0 0 0 0 0   0 1 0 0 1   1 0 0 0 1   1 1 0 1 0   0 0 1 0 1   0 1 1 1 0   1 0 1 1 0   1 1 1 1 1      输入端口A、B、$C_{in}$（进位输入）\n  输出端口S（和）、$C_{out}$（进位输出）\n  4-bit加法器\n    加法运算的实现\n  检查加法运算结果是否溢出（溢出 overflow：运算结果超出了正常的表示范围）\n  仅针对有符号数运算\n 两个正数相加，结果为负数 两个负数相加，结果为正数    进位$\\nLeftrightarrow$溢出\n  溢出的检查方法：最高位的进位输入不等于最高位的进位输出\n  对“溢出”的处理方式（MIPS）：提供两类不同的指令分别处理\n 将操作数看做有符号数，发生“溢出”时产生异常  add rd, rs, rt # R[rd] = R[rs] + R[rt] addi rt, rs, imm # R[rt] = R[rs] + SignExtImm   将操作数看做无符号数，不处理“溢出”  addu rd, rs, rt # R[rd] = R[rs] + R[rt] addiu rt, rs, imm # R[rt] = R[rs] + SignExtImm      对“溢出”的处理方式（x86）：溢出标志 OF（Overflow Flag ）\n 若发生溢出，则自动设置OF=1；否则，OF=0        减法运算\n  减法运算均可转换为加法运算：$A-B=A+(-B)$\n  补码表示的二进制数的相反数：按位取反，末位加一\n 正数的原码=补码；负数如-3，原码1011，符号位不变，其余各位取反，末位加1：1100+1=1101    在加法器的基础上实现减法器：$A+(-B)=A+(\\textasciitilde B+1)$\n    3.6 加法器的优化   行波进位加法器 Ripple-Carry Adder，RCA\n  结构特点：低位全加器的$C_{out}$连接到高一位全加器$C_{in}$\n  优点：电路布局简单，设计方便\n  缺点：高位的运算必须等待地位的运算完成，延迟时间长\n  性能分析：4-bit RCA的门电路实现中的关键路径（延迟最长的路径）\n  线延迟、门延迟：在进行设计原理分析时，主要关注门延迟（T）\n  总延迟时间：$(T+T)\\times4+T=9T \\to (T+T)\\times n+T=(2n+1)T$\n  32-bit RCA的性能分析\n        加法器的优化思路：高位的运算必须等待低位的“进位输出信号”→能否提前计算出“进位输出信号”？\n  进位输出信号的分析\n $C_{i+1}=(A_i\\cdot B_i)+(A_i\\cdot C_i)+(B_i\\cdot C_i)=(A_i\\cdot B_i)+(A_i+B_i)\\cdot C_i$：$A_i,B_i,C_i$中任意两个为1，则进位为1 设生成（Generate）信号$G_i=A_i\\cdot B_i$、传播（Propagate）信号$P_i=A_i+B_i$：均已知 则$C_{i+1}=G_i+P_i\\cdot C_i$  $C_{1}=G_{0}+P_{0}\\cdot C_{0}$ $C_{2}=G_{1}+P_{1}\\cdot C_{1}=G_{1}+P_{1}\\cdot(G_{0}+P_{0}\\cdot C_{0})=G_{1}+P_{1}\\cdot G_{0}+P_{1}\\cdot P_{0}\\cdot C_{0}$ $C_{3}=G_{2}+P_{2}\\cdot C_{2}=G_{2}+P_{2}\\cdot(G_{1}+P_{1}\\cdot G_{0}+P_{1}\\cdot P_{0}\\cdot C_{0})=G_{2}+P_{2}\\cdot G_{1}+P_{2}\\cdot P_{1}\\cdot G_{0}+P_{2}\\cdot P_{1}\\cdot P_{0}\\cdot C_{0}$ $C_{4}=G_{3}+P_{3}\\cdot C_{3}=G_{3}+P_{3}\\cdot(G_{2}+P_{2}\\cdot G_{1}+P_{2}\\cdot P_{1}\\cdot G_{0}+P_{2}\\cdot P_{1}\\cdot P_{0}\\cdot C_{0})=G_{3}+P_{3}\\cdot G_{2}+P_{3}\\cdot P_{2}\\cdot G_{1}+P_{3}\\cdot P_{2}\\cdot P_{1} \\cdot G_{0}+P_{3}\\cdot P_{2}\\cdot P_{1}\\cdot P_{0}\\cdot C_{0}$      提前计算$C_4$的电路实现\n 优点：计算$C_{i+1}$的延迟时间固定为三级门延迟，与加法器的位数无关 缺点：如果进一步拓宽加法器的位数，则电路变得非常复杂    超前进位加法器 Carry-Lookahead Adder，CLA\n* 4-bit RCA总延迟时间为9T\n  32-bit加法器采用行波进位总延迟时间为65T，而采用完全的超前进位理想的总延迟时间为4T，但实际上电路过于复杂而难以实现\n  通常采用多个小规模的CLA拼接而成（如用4个8-bit的CLA以RCA的方式连接）\n    延迟时间 时钟频率     32-bit RCA 1.3ns 769MHz   单个CLA 0.08ns /   4级CLA 0.26ns 3.84GHz    * 注：参照28nm制造工艺，门延迟设为0.02ns\n      第四讲 乘法器和除法器（Multiplier and Divider）  内容要点：乘法运算，乘法器的实现，除法运算，除法器的实现\n 4.1 乘法的运算过程 第五讲 单周期处理器（Single Cycle Processor） 内容要点：控制器，数据通路\n第六讲 流水线处理器（Pipelined Processor） 内容要点：流水线，相关和冒险\n第七讲 存储层次结构（Memory Hierarchy） 内容要点：高速缓存，主存\n第八讲 中断与异常（Interruption and Exception） 内容要点：中断与异常的异同，中断处理的过程\n第九讲 输入输出设备（Input/Output Devices） 内容要点：基本的输入输出控制方式，常用的输入输出设备类型\n","date":"2022-03-14T20:45:48+08:00","image":"https://crap.hongb.in/post/computer-architecture-notes/cover_huad24c60f3de9c0b9f5f96d6417dfa61d_108328_120x120_fill_q75_box_smart1.jpg","permalink":"https://crap.hongb.in/post/computer-architecture-notes/","title":"Computer Architecture Notes"},{"content":"Bootstrap：移动优先的响应性网页/应用程序前端框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026#34; integrity=\u0026#34;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;/\u0026gt; // 引入 Bootstrap \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://use.fontawesome.com/releases/v5.8.1/css/all.css\u0026#34; integrity=\u0026#34;sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; // 引入 Font Awesome 图标库 \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;text-primary text-center\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; // 主要文本、居中 \u0026lt;img class=\u0026#34;img-responsive\u0026#34; src=\u0026#34;https://cdn.freecodecamp.org/curriculum/cat-photo-app/running-cats.jpg\u0026#34;\u0026gt; // 图片自适应 \u0026lt;button class=\u0026#34;btn btn-default\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; // Bootstrap 按钮 \u0026lt;button class=\u0026#34;btn btn-default btn-block\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; // 块级元素（伸展并填满水平空间） \u0026lt;button class=\u0026#34;btn btn-primary btn-block\u0026#34;\u0026gt;Like\u0026lt;/button\u0026gt; // 主题色，引导操作 \u0026lt;button class=\u0026#34;btn btn-info btn-block\u0026#34;\u0026gt;Info\u0026lt;/button\u0026gt; // 备选操作 \u0026lt;button class=\u0026#34;btn btn-block btn-danger\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; // 危险操作 \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; // 12 列响应式栅格系统 \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;btn btn-block btn-primary\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-thumbs-up\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Like\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; // 点赞图标 \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;btn btn-block btn-info\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-info-circle\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Info\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;btn btn-block btn-danger\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-trash\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Delete\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; // 通过使用行内元素 span 把不同的元素放在同一行，为一行的不同部分指定不同样式 \u0026lt;p\u0026gt;Things cats \u0026lt;span class=\u0026#34;text-danger\u0026#34;\u0026gt;love\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;https://freecatphotoapp.com/submit-cat-photo\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-xs-6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;well\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; // 使页面更有层次感 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;indoor-outdoor\u0026#34;\u0026gt; Indoor\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-xs-6\u0026#34;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;indoor-outdoor\u0026#34;\u0026gt; Outdoor\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;personality\u0026#34;\u0026gt; Loving\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;personality\u0026#34;\u0026gt; Lazy\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-xs-4\u0026#34;\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;personality\u0026#34;\u0026gt; Crazy\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;cat photo URL\u0026#34; required\u0026gt; // 占满100%的宽度 \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-paper-plane\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt;   jQuery：用于简化HTML与JavaScript之间操作的跨浏览器 JavaScript 库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \u0026lt;script src=\u0026#34;https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.6.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // 引入 \u0026lt;script\u0026gt; $(document).ready(function() { // 防止代码在 HTML 页面呈现之前运行  $(\u0026#34;button\u0026#34;).addClass(\u0026#34;animated bounce\u0026#34;); // 所有的 jQuery 函数都以 $ 开头、添加跳跃效果类  $(\u0026#34;.well\u0026#34;).addClass(\u0026#34;animated shake\u0026#34;); $(\u0026#34;#target3\u0026#34;).addClass(\u0026#34;animated fadeOut\u0026#34;); $(\u0026#34;button\u0026#34;).removeClass(\u0026#34;btn-default\u0026#34;); // 移除类  $(\u0026#34;#target1\u0026#34;).css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 改变 CSS  $(\u0026#34;button\u0026#34;).prop(\u0026#34;disabled\u0026#34;, true); // 改变属性  $(\u0026#34;h3\u0026#34;).html(\u0026#34;\u0026lt;em\u0026gt;jQuery Playground\u0026lt;/em\u0026gt;\u0026#34;); // 在标签里添加并替换原有 HTML 标签和文本  $(\u0026#34;#target4\u0026#34;).remove(); // 移除元素  $(\u0026#34;#target4\u0026#34;).appendTo(\u0026#34;#left-well\u0026#34;); // 选取 HTML 标签并添加至另一个标签里  $(\u0026#34;#target2\u0026#34;).clone().appendTo(\u0026#34;#right-well\u0026#34;); // 复制标签  $(\u0026#34;#left-well\u0026#34;).parent().css(\u0026#34;background-color\u0026#34;, \u0026#34;blue\u0026#34;); // 访问父标签  $(\u0026#34;#left-well\u0026#34;).children().css(\u0026#34;color\u0026#34;, \u0026#34;blue\u0026#34;); // 访问子标签  $(\u0026#34;.target:nth-child(3)\u0026#34;).addClass(\u0026#34;animated bounce\u0026#34;); // 选取指定 class 或者元素类型的第 n 个标签  $(\u0026#34;.target:odd\u0026#34;).addClass(\u0026#34;animated shake\u0026#34;); // 奇偶（:even）选择器：jQuery 是零索引（zero-indexed）的，这意味着第 1 个标签的位置编号是 0。 :odd 表示选择第 2 个标签（位置编号 1），第 4 个标签（位置编号 3）……  $(\u0026#34;body\u0026#34;).addClass(\u0026#34;animated hinge\u0026#34;); // 掉落动画类  }); \u0026lt;/script\u0026gt;   Sass：Syntactically Awesome StyleSheets，对 CSS 的扩展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  \u0026lt;style type=\u0026#39;text/scss\u0026#39;\u0026gt; $text-color: red; // 允许使用变量 .header{ text-align: center; } .blog-post, h2 { color: $text-color; } nav { // 允许 CSS 嵌套 background-color: red; ul { list-style: none; li { display: inline-block; } } } @mixin box-shadow($x, $y, $blur, $c){ // Mixins 创建可重用 CSS -webkit-box-shadow: $x $y $blur $c; -moz-box-shadow: $x $y $blur $c; -ms-box-shadow: $x $y $blur $c; box-shadow: $x $y $blur $c; } div { @include box-shadow(0px, 0px, 4px, #fff); } @mixin text-effect($val) { // 条件判断语句 @if $val == danger { color: red; } @else if $val == alert { color: yellow; } @else if $val == success { color: green; } @else { color: black; } } @for $i from 1 through 12 { // @for 循环 .col-#{$i} { width: 100%/12 * $i; } // #{$i} 将变量 i 与文本组合成字符串 } // 相当于 .col-1 { width: 8.33333%; } .col-2 { width: 16.66667%; } ... .col-12 { width: 100%; } @each $color in blue, red, green { // @each 循环遍历列表 .#{$color}-text {color: $color;} } $colors: (color1: blue, color2: red, color3: green); // // @each 循环遍历映射 @each $key, $color in $colors { // $key 变量引用 map 中的键 .#{$color}-text {color: $color;} } // 相当于 .blue-text { color: blue; } .red-text { color: red; } .green-text { color: green; } $x: 1; // @while 循环 @while $x \u0026lt; 13 { .col-#{$x} { width: 100%/12 * $x;} $x: $x + 1; } // Partials：名称以下划线（_）字符开头，这样 Sass 就知道它是 CSS 的一小部分，而不会将其转换为 CSS 文件。 此外，Sass 文件以 .scss 文件扩展名结尾。例如，如果所有 mixins 都保存在名为 “_mixins.scss” 的 partial 中，并且在 “main.scss” 文件中需要它们 @import \u0026#39;mixins\u0026#39; // import 语句中不需要下划线 .panel { // CSS 样式重用 background-color: red; height: 70px; border: 2px solid green; } .big-panel { @extend .panel; width: 150px; font-size: 2em; } \u0026lt;/style\u0026gt;   React：构建可重用组件驱动的用户界面  JSX 是 JavaScript 的语法扩展，用以在 JavaScript 中编写 HTML 在花括号中编写希望被视为 JavaScript 的代码 { 'this is treated as JavaScript code' } 转换器 Babel 将 JSX 编译成 JavaScript ReactDOM.render(JSX, document.getElementById('root')) 函数调用将 JSX 置于 React 自己的轻量级 DOM 中，React 使用自己的 DOM 快照来实现增量更新 嵌套的 JSX 必须返回单个元素，父元素包裹所有其他级别的嵌套元素  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178  const JSX = ( \u0026lt;div className=\u0026#34;myDiv\u0026#34;\u0026gt; // className 代替 class，属性和事件引用命名约定均变为驼峰式  {/* 注释 */} \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Lets render this to the DOM\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div /\u0026gt; // 自闭合标签，无法在其中包含任何内容，用于渲染 React 组件 ); ReactDOM.render(JSX, document.getElementById(\u0026#39;challenge-node\u0026#39;)); // 渲染到 DOM 节点  const DemoComponent = function() { // JavaScript 函数创建无状态功能组件（能接收数据并对其进行渲染，但不管理或跟踪该数据的更改，不使用内部状态），是一个类，扩展了React.Component，返回 JSX 或 null，函数名以大写字母开头  return ( \u0026lt;div className=\u0026#39;customClass\u0026#39; /\u0026gt; ); }; class Kitten extends React.Component { // 扩展了 React.Component 的 ES6 类，可以访问 React 功能如本地状态和生命周期钩子  constructor(props) { super(props); // 调用父类的构造函数（React.Component）  } render() { return ( \u0026lt;h1\u0026gt;Hi\u0026lt;/h1\u0026gt; ); } } const ChildComponent = () =\u0026gt; { // App 父组件渲染子组件，组件可嵌套渲染  return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;I am the child\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; class ParentComponent extends React.Component { constructor(props) { super(props); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;I am the parent\u0026lt;/h1\u0026gt; \u0026lt;ChildComponent /\u0026gt; \u0026lt;/div\u0026gt; ); } }; ReactDOM.render(\u0026lt;ParentComponent /\u0026gt;, document.getElementById(\u0026#39;challenge-node\u0026#39;)); // 渲染组件  const CurrentDate = (props) =\u0026gt; { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;The current date is: {props.date}\u0026lt;/p\u0026gt; // props 将属性传递给子组件 // ES6 类组件则使用 {this.props.date} 访问  \u0026lt;/div\u0026gt; ); }; CurrentDate.defaultProps = { location: \u0026#39;San Francisco\u0026#39; } // 设置默认 props import PropTypes from \u0026#39;prop-types\u0026#39;; MyComponent.propTypes = { location: PropTypes.func.isRequired } // 检查传入 props 的类型（func 代表 function，bool 代表 boolean）：https://reactjs.org/docs/typechecking-with-proptypes.html#proptypes class Calendar extends React.Component { constructor(props) { super(props); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;What date is it?\u0026lt;/h3\u0026gt; \u0026lt;CurrentDate date={Date()}/\u0026gt; \u0026lt;/div\u0026gt; ); } }; // state 使用虚拟 DOM 来跟踪数据的变化，并根据数据的变化渲染 UI // 当 state 数据更新时，它会使用该数据触发组件的重新渲染，包括接收 prop 数据的子组件 // React 只在必要的时候更新实际的 DOM。 class StatefulComponent extends React.Component { // 创建类组件必须扩展 React.Component  constructor(props) { super(props); this.state = { // 通过在 constructor 中声明 state 属性在 React 组件中创建 state，属性为 object  name: \u0026#34;John\u0026#34; } this.setState({ // 修改 State，React 可以异步批量处理多个 state 更新 👉 SHOULD NOT rely on their values for calculating the next state  username: \u0026#39;Lewis\u0026#39; }); this.setState((state, props) =\u0026gt; ({ // 以先前的状态和当前的属性设置状态的正确方法  counter: state.counter + props.increment })); // object 应放在括号里以免被 JavaScript 认为代码片段  } // render() 之前也可以从 state 或 props 中访问数据、对此数据执行计算等  render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{this.state.name}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } }; class ControlledInput extends React.Component { constructor(props) { super(props); this.state = { input: \u0026#39;\u0026#39; }; this.handleChange = this.handleChange.bind(this); } handleChange(event) { this.setState({ input: event.target.value // 访问传递的事件  }) } render() { return ( \u0026lt;div\u0026gt; \u0026lt;input value={this.state.input} onChange={this.handleChange}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;h4\u0026gt;Controlled Input:\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;{this.state.input}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } }; class MyForm extends React.Component { constructor(props) { super(props); this.state = { input: \u0026#39;\u0026#39;, submit: \u0026#39;\u0026#39; }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({ input: event.target.value // 访问传递的事件  }); } handleSubmit(event) { event.preventDefault(); // 防止新网页的默认的表单提交行为  this.setState({ submit: this.state.input }); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;form onSubmit={this.handleSubmit}\u0026gt; \u0026lt;input value={this.state.input} onChange={this.handleChange}\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button type=\u0026#39;submit\u0026#39;\u0026gt;Submit!\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;h1\u0026gt;{this.state.submit}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } } // 生命周期方法：componentDidMount() shouldComponentUpdate() componentDidUpdate() componentWillUnmount() // 应在将组件装载到 DOM 后被调用的 componentDidMount() 中对服务器进行 API 调用或任何其它调用，此处对 setState() 的任何调用都将触发组件的重新渲染，即在此方法中调用 API 并用 API​​ 返回的数据设置 state 时收到数据将自动触发更新；特定功能所需的任何事件监听器也应在其中添加 // shouldComponentUpdate(nextProps, nextState) 返回一个 boolean，告诉 React 是否更新组件，防止组件接收到新的但没有改变的 props 时也重新渲染  \u0026lt;div style={{color: \u0026#34;yellow\u0026#34;, fontSize: 16}}\u0026gt;Mellow Yellow\u0026lt;/div\u0026gt; // 内联样式值为 object；属性名使用驼峰式；可以选择将字体大小设置为数字，省略单位 px，或者将其写为 \u0026#34;72px\u0026#34; render() { // 修改这行下面的代码  return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={this.toggleDisplay}\u0026gt;Toggle Display\u0026lt;/button\u0026gt; {this.state.display \u0026amp;\u0026amp; \u0026lt;h1\u0026gt;Displayed!\u0026lt;/h1\u0026gt;} // 条件判断的简易写法：如果 condition 为 true，则返回标记；如果条件为 false ，则在评估 condition 后操作将立即返回 false，并且不返回任何内容 // 也可使用三元运算符  \u0026lt;/div\u0026gt; ); } // ReactDOMServer.renderToString(\u0026lt;App /\u0026gt;) 在服务器上渲染 // 当 React 应用程序最初加载到浏览器时包含一个代码量很少的 HTML 文件和一大堆 JavaScript，不利于搜索引擎索引 // 在服务器上渲染初始 HTML 标记并将其发送到客户端，则初始页面加载的内容包含搜索引擎可以抓取的所有页面标记 // React 仍然能够识别应用并在初始加载后进行管理。   Redux：JavaScript 应用的可预测状态容器 Redux 中由且仅由一个状态对象负责应用程序的整个状态。\n所有状态更新都由 dispatch action 触发，action 只是一个 JavaScript 对象，其中包含有关已发生的 action 事件的信息。Redux store 接收这些 action 对象，然后更新相应的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  const LOGIN = \u0026#39;LOGIN\u0026#39;; const LOGOUT = \u0026#39;LOGOUT\u0026#39;; // 通常用常量消除魔法字符  const defaultState = { authenticated: false }; const authReducer = (state = defaultState, action) =\u0026gt; { // reducer 函数负责响应 action 进行状态的修改：以 state 和 action 作为参数，返回新的 state；reducer 不应该调用 API 接口、不应存在任何潜在的副作用  switch (action.type) { case LOGIN: return { authenticated: true } case LOGOUT: return { authenticated: false } default: return state; // state 是只读的，永远不会直接修改状态，因此必须返回当前的 state；当程序有多个 reducer，每一个 action 被 dispatch 时它们都会运行，即使 action 与该 reducer 无关，此时要确保返回当前的 state  } }; const store = Redux.createStore(authReducer); // store 是一个保存和管理应用程序状态的 state  const loginUser = () =\u0026gt; { // action creator  return { type: LOGIN, message: \u0026#34;Hello!\u0026#34; } }; const logoutUser = () =\u0026gt; { return { type: LOGOUT } }; store.dispatch(loginUser()); // 使用 dispatch 发送 action  let currentState = store.getState(); // 获取当前 state  let count = 0; store.subscribe(() =\u0026gt; count++); // 监听器函数只要 action 被 dispatch 就会被调用  const rootReducer = Redux.combineReducers({ // 组合多个 Reducers  auth: authenticationReducer, notes: notesReducer }); // Redux Thunk 中间件 // 判断每个经过它的action：如果是function类型，就调用这个function（并传入 dispatch 和 getState 及 extraArgument 为参数），而不是任由让它到达 reducer，因为到达 reducer 的 action 必须为 plain object import thunkMiddleware from \u0026#39;redux-thunk\u0026#39; const REQUESTING_DATA = \u0026#39;REQUESTING_DATA\u0026#39; const RECEIVED_DATA = \u0026#39;RECEIVED_DATA\u0026#39; const requestingData = () =\u0026gt; { return {type: REQUESTING_DATA} } const receivedData = (data) =\u0026gt; { return {type: RECEIVED_DATA, users: data.users} } const handleAsync = () =\u0026gt; { return function(dispatch) { // 以 dispatch 为参数，实现多次 dispatch  dispatch(requestingData()); setTimeout(function() { let data = { users: [\u0026#39;Jeff\u0026#39;, \u0026#39;William\u0026#39;, \u0026#39;Alice\u0026#39;] }; dispatch(receivedData(data)); }, 2500); } }; const defaultState = { fetching: false, users: [] }; const asyncDataReducer = (state = defaultState, action) =\u0026gt; { switch(action.type) { case REQUESTING_DATA: return { fetching: true, users: [] } case RECEIVED_DATA: return { fetching: false, users: action.users } default: return state; } }; const store = createStore(asyncDataReducer, Redux.applyMiddleware(thunkMiddleware)) // 第二个参数引入中间件   状态不变性关键原则\n不可变状态意味着永远不直接修改状态，而是返回一个新的状态副本。\n如果拍摄 Redux 应用程序一段时间状态的快照，会看到类似 state 1，state 2，state 3，state 4，... 等等，但每个状态都是一个独特的数据。这种不变性提供了时间旅行调试等功能。\n但 Redux 并没有主动地在其 store 或者 reducer 中强制执行状态不变性（如状态中可变的 array 或 object）而需要手动实现。\nobject 状态可以使用 Object.assign({}, obj1, obj2) 拷贝对象实现状态不变性。\nReact × Redux\n  创建单一的 Redux store 来管理整个应用的状态（特定本地状态的独立组件除外）\n  React 组件仅订阅 store 中与其角色相关的数据\n  直接从 React 组件中分发 actions 以触发 store 对象的更新\n  react-redux 包提供 wrapper 组件 Provider 和 connect\n  Provider 将 state 和 dispatch 作为组件的 props\n mapStateToProps() 将 state 映射至对象上特定属性名上 mapDispatchToProps() 将 dispatch actions 映射到属性名上 connect(mapStateToProps | null, mapDispatchToProps | null)(MyComponent) 将参数中对象映射到 props    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  // Redux: const ADD = \u0026#39;ADD\u0026#39;; const addMessage = (message) =\u0026gt; { return { type: ADD, message: message } }; const messageReducer = (state = [], action) =\u0026gt; { switch (action.type) { case ADD: return [ ...state, action.message ]; default: return state; } }; const store = Redux.createStore(messageReducer); // React: class Presentational extends React.Component { // Presentational 指未直接连接到 Redux 的 React 组件，只负责执行接收 props 的函数来实现 UI 的呈现  constructor(props) { super(props); this.state = { input: \u0026#39;\u0026#39; } this.handleChange = this.handleChange.bind(this); this.submitMessage = this.submitMessage.bind(this); } handleChange(event) { this.setState({ input: event.target.value }); } submitMessage() { this.props.submitNewMessage(this.state.input) this.setState((state) =\u0026gt; ({ input: \u0026#39;\u0026#39; })); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Type in a new Message:\u0026lt;/h2\u0026gt; \u0026lt;input value={this.state.input} onChange={this.handleChange}/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;button onClick={this.submitMessage}\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;ul\u0026gt; {this.props.messages.map( (message, idx) =\u0026gt; { return ( \u0026lt;li key={idx}\u0026gt;{message}\u0026lt;/li\u0026gt; ) }) } \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } }; // React-Redux: const mapStateToProps = (state) =\u0026gt; { return { messages: state } }; const mapDispatchToProps = (dispatch) =\u0026gt; { return { submitNewMessage: (newMessage) =\u0026gt; { dispatch(addMessage(newMessage)) } } }; const Provider = ReactRedux.Provider; const connect = ReactRedux.connect; const Container = connect(mapStateToProps,mapDispatchToProps)(Presentational); // Container 组件用来连接到 Redux 上，负责把 actions 分派给 store、给子组件传入 store state 属性  class AppWrapper extends React.Component { constructor(props) { super(props); } render() { return ( \u0026lt;Provider store={store}\u0026gt; \u0026lt;Container /\u0026gt; \u0026lt;/Provider\u0026gt; ); } };   本地引入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; import { Provider, connect } from \u0026#39;react-redux\u0026#39; import { createStore, combineReducers, applyMiddleware } from \u0026#39;redux\u0026#39; import thunk from \u0026#39;redux-thunk\u0026#39; import rootReducer from \u0026#39;./redux/reducers\u0026#39; import App from \u0026#39;./components/App\u0026#39; const store = createStore( rootReducer, applyMiddleware(thunk) ); ReactDOM.render( \u0026lt;Provider store={store}\u0026gt; \u0026lt;App/\u0026gt; \u0026lt;/Provider\u0026gt;, document.getElementById(\u0026#39;root\u0026#39;) );   ","date":"2022-02-21T20:38:19+08:00","image":"https://crap.hongb.in/post/basic-front-end-development-libraries/cover_hud007b7c6718c8946113d57264ec40bdd_186528_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://crap.hongb.in/post/basic-front-end-development-libraries/","title":"Basic Front-end Development Libraries"},{"content":"JavaScript高级程序设计（第4版） 第1章 什么是 JavaScript JavaScript 实现  核心 (ECMAScript): 语法、类型、语句、关建字、保留字、操作符、全局对象 文档对象模型 (Document Object Model)：将整个 HTML 或 XML 网页内容抽象为一组包含不同的数据的分层节点，并以 DOM 视图、事件、样式、遍历和范围 API 的形式实现节点的删除、添加、替换、修改 浏览器对象模型 (Browser Object Model)：用于支持访问和操作浏览器的窗口的 API  HTML 中的 JavaScript \u0026lt;script\u0026gt; 元素 所有 \u0026lt;script\u0026gt; 元素依照出现次序被解释。浏览器解释完 \u0026lt;script\u0026gt; 中的代码才继续渲染页面的剩余部分。为此，通常应该把 \u0026lt;script\u0026gt; 元素放到页面主内容之后及 \u0026lt;/body\u0026gt; 标签之前。\n src：表示包含要执行的代码的外部文件。 async：立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。异步脚本不应该在加载期间修改 DOM。 defer：脚本可以延迟到文档完全被解析和显示之后再按列出的顺序执行。只对外部脚本文件有效。 crossorigin：配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。crossorigin=\u0026quot;anonymous\u0026quot; 配置文件请求不必设置凭据标志。crossorigin=\u0026quot;use-credentials\u0026quot; 设置凭据标志，意味着出站请求会包含凭据。 integrity：允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。 type：表示代码块中脚本语言的内容类型（也称MIME 类型）。按照惯例，这个值始终都是 \u0026quot;text/javascript\u0026quot;，尽管 \u0026quot;text/javascript\u0026quot; 和 \u0026quot;text/ecmascript\u0026quot; 都已经废弃了。JavaScript 文件的MIME 类型通常是 \u0026quot;application/x-javascript\u0026quot;，不过给 type 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有 \u0026quot;application/javascript\u0026quot; 和 \u0026quot;application/ecmascript\u0026quot;。如果这个值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。  动态加载脚本 1 2 3 4  let script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;gibberish.js\u0026#39;; script.async = false; document.head.appendChild(script);   1  \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;gibberish.js\u0026#34;\u0026gt;   \u0026lt;noscript\u0026gt; 元素 第3章 语言基础 语法  区分大小写 标识符以 字母/_/$ 开始，驼峰表示，可使用 Unicode 字母字符 // 单行注释，/* */ 多行注释 \u0026quot;use strict\u0026quot;; 预处理指令启用严格模式 句尾应加 ;（即使非必须） { } 合并多条语句的代码块  关键字  break do in typeof case else instanceof var catch export new void class extends return while const finally super with continue for switch yield debugger function this default if throw delete import try enum 严格模式下 implements package public interface protected static let private 模块代码中 await  变量声明  const：块作用域；声明变量时必须同时初始化变量；不能修改声明的变量（若变量引用的是一个对象，修改对象内部的属性是允许的） let：块作用域；不允许同一块作用域中重复声明（可以嵌套使用）；不会在作用域中被提升，产生暂时性死区（temporal dead zone）；在全局作用域中声明的变量不会成为 window 对象的属性；不能使用条件式声明，for 循环定义的迭代变量不会渗透到循环体外部 var：函数作用域；去掉 var 操作符定义全局变量，严格模式中会抛出 ReferenceError；严格模式中不能定义名为 eval / arguments 的变量；声明的变量会自动提升（hoist）到函数作用域顶部；允许重复声明（在作用于顶部合并）  数据类型  简单数据类型 / 原始类型：Undefined、Null、Boolean、Number、String、Symbol 复杂数据类型：Object  typeof 操作符返回字符串：\n  \u0026quot;undefined\u0026quot; 表示值未定义（使用 var 或 let 声明了变量但没有初始化），是一个假值\n1 2 3 4 5 6 7 8 9 10 11  let message; // 这个变量被声明了，只是值为undefined // 确保没有声明过这个变量 // let age console.log(message); // \u0026#34;undefined\u0026#34; console.log(age); // 报错  let message; // 这个变量被声明了，只是值为undefined // 确保没有声明过这个变量 // let age console.log(typeof message); // \u0026#34;undefined\u0026#34; console.log(typeof age); // \u0026#34;undefined\u0026#34;   未初始化的变量会被自动赋予 undefined 值，应在声明变量的同时进行初始化，以便判断返回 \u0026quot;undefined\u0026quot; 的 typeof 是给定的变量尚未声明还是声明了但未初始化。\n  \u0026quot;boolean\u0026quot; 表示值为布尔值\nBoolean() 转型函数转换规则：\n   数据类型 转换为 true 的值 转换为 false 的值     Boolean true false   String 非空字符串 \u0026quot;\u0026quot;（空字符串）   Number 非零数值（包括无穷值） 0、NaN   Object 任意对象 null   Undefined N/A（不存在） undefined      \u0026quot;number\u0026quot; 表示值为数值\n  使用 IEEE 754 格式表示整数和浮点值，存在浮点舍入错误\n  0 / 0o 数值前缀表示八进制字面量（0 在严格模式下无效），0x 表示十六进制字面量\n  .1 有效但不推荐\n  1. / 10.0 会被转化成整数\n  支持科学计数法表示 3.125e7，小数点后至少包含六个零的浮点值将被转换为科学计数法\n  可表示的范围为 Number.MIN_VALUE ~ Number.MAX_VALUE，超出则会转化为Number.NEGATIVE_INFINITY 或 Number.POSITIVE_INFINITY 属性中的 Infinity / -Infinity，如 $\\frac{有符号 0 或无符号 0}{非 0}$，使用 isFinite()判断\n  NaN 意为 Not a Number，表示本来要返回数值的操作失败了，如除 0\n 任何涉及 NaN 的操作始终返回 NaN NaN 不等于包括 NaN 在内的任何值 任何不能转化为数值的值都会导致 isNaN() 函数返回 true    数值转换\n  转型函数 Number()\n 一元加操作符与Number()函数遵循相同的转换规则。\n    参数 返回值     布尔值 true 转换为 1，false 转换为 0   数值 直接返回   null 返回 0   undefined 返回 NaN   字符串 如果包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值（Number(\u0026quot;011\u0026quot;) 忽略前面的零返回 11）；如果包含有效的浮点值格式如 \u0026quot;1.1\u0026quot;，则会忽略前面的零转换为相应的浮点值；如果包含有效的十六进制格式如 \u0026quot;0xf\u0026quot;，则会转换为与该十六进制值对应的十进制整数值；如果是 \u0026quot;\u0026quot;，则返回 0； 如果包含除上述情况之外的其他字符，则返回 NaN   对象 调用 valueOf() 方法，并按照上述规则转换返回的值；如果转换结果是 NaN，则调用 toString() 方法，再按照转换字符串的规则转换      parseInt() 函数\n 忽略字符串最前面的空格，从第一个非空格字符开始转换；如果第一个字符不是数值字符、加号或减号，立即返回 NaN（因此 \u0026quot;\u0026quot; 会返回 NaN）；否则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符（不同的整数格式前缀除外，亦可传入第二个参数指定进制数） 为避免解析出错，应始终传入第二个参数    parseFloat() 函数\n 类似 parseInt() 函数，支持包括科学计数法在内的所有浮点格式 第二次出现的小数点及以后的剩余字符都会被忽略 始终忽略字符串开头的零 仅十进制        \u0026quot;string\u0026quot; 表示值为字符串\n  字符串以' / \u0026quot; / ` 表示，是不可改变的\n  字符字面量\n   字面量 含义     \\n 换行   \\t 制表   \\b 退格   \\r 回车   \\f 换页   \\\\ 反斜杠   \\' 单引号   \\\u0026quot; 双引号   \\`  反引号   \\xnn 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如 \\x41 等于 \u0026quot;A\u0026quot;   \\unnnn 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如 \\u03a3 等于希腊字符 \u0026quot;Σ\u0026quot;      字符串的长度可以通过其 length 属性获取\n 如果字符串中包含双字节字符，那么length 属性返回的值可能不是准确的字符数。 第 5 章将具体讨论如何解决这个问题\n   toString() 方法转换为字符串\n  null 和 undefined 值没有 toString() 方法，可使用 String() 转型函数：\n  如果值有 toString() 方法，则调用该方法（不传参数）并返回结果\n  如果值是 null，返回 \u0026quot;null\u0026quot;\n  如果值是 undefined，返回 \u0026quot;undefined\u0026quot;\n 用加号操作符给一个值加上一个空字符串 \u0026quot;\u0026quot; 也可以将其转换为字符串\n     对数值调用时，可接受底数参数\n    模板字面量：` 保留换行字符，保持内部的空格\n  字符串插值：所有以 ${} 插入的值都会使用 toString() 强制转型为字符串，而且任何JavaScript 表达式都可以用于插值\n1 2 3 4 5 6 7 8  let value = 5; let exponent = \u0026#39;second\u0026#39;; // 以前，字符串插值是这样实现的： let interpolatedString = value + \u0026#39; to the \u0026#39; + exponent + \u0026#39; power is \u0026#39; + (value * value); // 现在，可以用模板字面量这样实现： let interpolatedTemplateLiteral = `${ value }to the ${ exponent }power is ${ value * value }`; console.log(interpolatedString); // 5 to the second power is 25 console.log(interpolatedTemplateLiteral); // 5 to the second power is 25     标签函数：接收被插值记号分隔后的模板和对每个表达式求值的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  let a = 6; let b = 9; function simpleTag(strings, ...expressions) { console.log(strings); for(const expression of expressions) { console.log(expression); } return \u0026#39;foobar\u0026#39;; } function zipTag(strings, ...expressions) { return strings[0] + expressions.map((e, i) =\u0026gt; `${e}${strings[i + 1]}`).join(\u0026#39;\u0026#39;); } let untaggedResult = `${ a }+ ${ b }= ${ a + b }`; let taggedResult = simpleTag`${ a }+ ${ b }= ${ a + b }`; // [\u0026#34;\u0026#34;, \u0026#34; + \u0026#34;, \u0026#34; = \u0026#34;, \u0026#34;\u0026#34;] // 6 // 9 // 15 let zipTaggedResult = zipTag`${ a }+ ${ b }= ${ a + b }`; console.log(untaggedResult); // \u0026#34;6 + 9 = 15\u0026#34; console.log(taggedResult); // \u0026#34;foobar\u0026#34; console.log(zipTaggedResult); // \u0026#34;6 + 9 = 15\u0026#34;     原始字符串：使用 String.raw 标签函数获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Unicode 示例 // \\u00A9 是版权符号 console.log(`\\u00A9`); // © console.log(String.raw`\\u00A9`); // \\u00A9 // 换行符示例 console.log(`first line\\nsecond line`); // first line // second line console.log(String.raw`first line\\nsecond line`); // \u0026#34;first line\\nsecond line\u0026#34; // 对实际的换行符来说是不行的 // 它们不会被转换成转义序列的形式 console.log(`first line second line`); // first line // second line console.log(String.raw`first line second line`); // first line // second line  function printRaw(strings) { console.log(\u0026#39;Actual characters:\u0026#39;); for (const string of strings) { console.log(string); } console.log(\u0026#39;Escaped characters;\u0026#39;); for (const rawString of strings.raw) { console.log(rawString); } } printRaw`\\u00A9${ \u0026#39;and\u0026#39; }\\n`; // Actual characters: // © //（换行符） // Escaped characters: // \\u00A9 // \\n         \u0026quot;symbol\u0026quot; 表示值为符号\n  符号用来创建不会命名冲突的唯一记号，作为对象属性的标识符\n  使用 Symbol() 函数初始化，可以传入一个字符串参数作为对符号的描述\n  为了避免创建符号包装对象，Symbol() 函数不能与 new 关键字一起作为构造函数使用（Boolean、String 或 Number 均可；使用符号包装对象可通过Object() 函数实现）\n  全局符号注册表\n  运行时的不同部分以 Symbol.for() 共享和重用符号实例\n  在全局注册表中定义的符号跟使用 Symbol() 定义的符号不等同\n  必须使用字符串键来创建\n1 2  let emptyGlobalSymbol = Symbol.for(); console.log(emptyGlobalSymbol); // Symbol(undefined)     Symbol.keyFor() 查询全局注册表，接收符号，返回全局符号对应的字符串键；如果查询的不是全局符号，则返回 undefined；如果查询的不是符号，则抛出 TypeError\n    使用符号作为属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  let s1 = Symbol(\u0026#39;foo\u0026#39;), s2 = Symbol(\u0026#39;bar\u0026#39;), s3 = Symbol(\u0026#39;baz\u0026#39;), s4 = Symbol(\u0026#39;qux\u0026#39;); let o = { [s1]: \u0026#39;foo val\u0026#39; }; // 这样也可以：o[s1] = \u0026#39;foo val\u0026#39;; console.log(o); // {Symbol(foo): foo val} Object.defineProperty(o, s2, {value: \u0026#39;bar val\u0026#39;}); console.log(o); // {Symbol(foo): foo val, Symbol(bar): bar val} Object.defineProperties(o, { [s3]: {value: \u0026#39;baz val\u0026#39;}, [s4]: {value: \u0026#39;qux val\u0026#39;} }); console.log(o); // {Symbol(foo): foo val, Symbol(bar): bar val, // Symbol(baz): baz val, Symbol(qux): qux val}   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let s1 = Symbol(\u0026#39;foo\u0026#39;), s2 = Symbol(\u0026#39;bar\u0026#39;); let o = { [s1]: \u0026#39;foo val\u0026#39;, [s2]: \u0026#39;bar val\u0026#39;, baz: \u0026#39;baz val\u0026#39;, qux: \u0026#39;qux val\u0026#39; }; console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar)] console.log(Object.getOwnPropertyNames(o)); // [\u0026#34;baz\u0026#34;, \u0026#34;qux\u0026#34;] console.log(Object.getOwnPropertyDescriptors(o)); // {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} console.log(Reflect.ownKeys(o)); // [\u0026#34;baz\u0026#34;, \u0026#34;qux\u0026#34;, Symbol(foo), Symbol(bar)]   1 2 3 4 5 6 7 8 9 10 11  // 符号属性是对内存中符号的一个引用，直接创建并用作属性的符号不会丢失 // 但如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键 let o = { [Symbol(\u0026#39;foo\u0026#39;)]: \u0026#39;foo val\u0026#39;, [Symbol(\u0026#39;bar\u0026#39;)]: \u0026#39;bar val\u0026#39; }; console.log(o); // {Symbol(foo): \u0026#34;foo val\u0026#34;, Symbol(bar): \u0026#34;bar val\u0026#34;} let barSymbol = Object.getOwnPropertySymbols(o).find((symbol) =\u0026gt; symbol.toString().match(/bar/)); console.log(barSymbol); // Symbol(bar)     常用内置符号（@@iterator $\\iff$ Symbol.iterator）：用于暴露语言内部行为，可以通过重新定义而改变原生结构的行为。如 for-of 循环会在相关对象上使用 Symbol.iterator 属性，就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为\n  Symbol.asyncIterator[ES2018]：表示实现异步迭代器 API 的函数，是一个返回对象供 for-await-of 语句使用的默认的 AsyncIterator 的方法\nfor-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以 Symbol.asyncIterator 为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 AsyncGenerator：\n1 2 3 4 5 6  class Foo { async *[Symbol.asyncIterator]() {} } let f = new Foo(); console.log(f[Symbol.asyncIterator]()); // AsyncGenerator {\u0026lt;suspended\u0026gt;}   技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next() 方法陆续返回 Promise 实例。可以通过显式地调用 next() 方法返回，也可以隐式地通过异步生成器函数返回：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Emitter { constructor(max) { this.max = max; this.asyncIdx = 0; } async *[Symbol.asyncIterator]() { while(this.asyncIdx \u0026lt; this.max) { yield new Promise((resolve) =\u0026gt; resolve(this.asyncIdx++)); } } } async function asyncCount() { let emitter = new Emitter(5); for await(const x of emitter) { console.log(x); } } asyncCount(); // 0 // 1 // 2 // 3 // 4    ❓ 关于异步迭代和 for-await-of 循环的细节，参见附录A。\n   Symbol.hasInstance：决定一个构造器对象是否认可一个对象是它的实例的方法，由 instanceof 操作符使用以确定一个对象实例的原型链上是否有原型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function Foo() {} let f = new Foo(); console.log(Foo[Symbol.hasInstance](f)); // true class Bar {} let b = new Bar(); console.log(Bar[Symbol.hasInstance](b)); // true  function Foo() {} let f = new Foo(); console.log(f instanceof Foo); // true class Bar {} let b = new Bar(); console.log(b instanceof Bar); // true  // 在继承的类上通过静态方法重新定义这个函数 class Bar {} class Baz extends Bar { static [Symbol.hasInstance]() { return false; } } let b = new Baz(); console.log(Bar[Symbol.hasInstance](b)); // true console.log(b instanceof Bar); // true console.log(Baz[Symbol.hasInstance](b)); // false console.log(b instanceof Baz); // false     Symbol.isConcatSpreadable ：一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat() 打平其数组元素\n数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾；类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let initial = [\u0026#39;foo\u0026#39;]; let array = [\u0026#39;bar\u0026#39;]; console.log(array[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(array)); // [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] array[Symbol.isConcatSpreadable] = false; console.log(initial.concat(array)); // [\u0026#39;foo\u0026#39;, Array(1)]  let arrayLikeObject = { length: 1, 0: \u0026#39;baz\u0026#39; }; console.log(arrayLikeObject[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(arrayLikeObject)); // [\u0026#39;foo\u0026#39;, {...}] arrayLikeObject[Symbol.isConcatSpreadable] = true; console.log(initial.concat(arrayLikeObject)); // [\u0026#39;foo\u0026#39;, \u0026#39;baz\u0026#39;] ❓  let otherObject = new Set().add(\u0026#39;qux\u0026#39;); console.log(otherObject[Symbol.isConcatSpreadable]); // undefined console.log(initial.concat(otherObject)); // [\u0026#39;foo\u0026#39;, Set(1)] otherObject[Symbol.isConcatSpreadable] = true; console.log(initial.concat(otherObject)); // [\u0026#39;foo\u0026#39;]     Symbol.iterator ：表示实现迭代器 API 的函数，返回对象默认的迭代器供 for-of 语句使用\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Foo { *[Symbol.iterator]() {} } let f = new Foo(); console.log(f[Symbol.iterator]()); // Generator {\u0026lt;suspended\u0026gt;}  class Emitter { constructor(max) { this.max = max; this.idx = 0; } *[Symbol.iterator]() { while(this.idx \u0026lt; this.max) { yield this.idx++; } } } function count() { let emitter = new Emitter(5); for (const x of emitter) { console.log(x); } } count(); // 0 // 1 // 2 // 3 // 4    Symbol.match：用正则表达式去匹配字符串的方法，String.prototype.match() 方法使 用以 Symbol.match 为键的函数来对正则表达式求值  1 2 3 4  console.log(RegExp.prototype[Symbol.match]); // ƒ [Symbol.match]() { [native code] } console.log(\u0026#39;foobar\u0026#39;.match(/bar/)); // [\u0026#34;bar\u0026#34;, index: 3, input: \u0026#34;foobar\u0026#34;, groups: undefined]    Symbol.toStringTag  Symbol.replace Symbol.search Symbol.split Symbol.toPrimitive  Symbol.species Symbol.unscopables       \u0026quot;object\u0026quot; 表示值为对象（而不是函数）或 null\nnull 值表示一个空对象指针，用于在定义将来要保存对象值的变量时初始化。undefined 值由 null 值派生而来。\n1  console.log(null == undefined); // true     \u0026quot;function\u0026quot; 表示值为函数（严格来讲函数是一种对象而非数据类型）\n  \r还没学\rJavaScript: The Definitive Guide, 7th Edition ES6 入门教程 你不知道的JavaScript \r零零碎碎   splice() 的第一个参数代表从数组中的哪个索引开始移除元素，而第二个参数表示要从数组中的这个位置开始删除多少个元素。 第三个参数可以是一个或多个元素，这些元素会被添加到数组中。\n  reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。注意: 对于空数组是不会执行回调函数的。\n1 2 3 4 5 6 7 8  array.reduce(function(total, currentValue, currentIndex, arr), initialValue) /* total\t必需。初始值, 或者计算结束后的返回值。 currentValue\t必需。当前元素 currentIndex\t可选。当前元素的索引 arr\t可选。当前元素所属的数组对象。 initialValue\t可选。传递给函数的初始值 */     map() 方法\n  slice() 方法\n  concat() 方法\n  filter() 方法\n  sort() 方法\n  split() 方法和 join() 方法\n  every() 方法和 some() 方法\n  _ 可忽略当前参数\n  正则表达式\n 正则表达式 /bird|cat/，/cat/i 忽略大小写，/g 全局多次匹配，/.un/ 匹配 *un，/[h-s2-6] 匹配多字母。 /a+/g 会在 abc 中匹配到一个匹配项，并且返回 [\u0026quot;a\u0026quot;]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 [\u0026quot;aa\u0026quot;]。如果它是检查字符串 abab，它将匹配到两个匹配项并且返回[\u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。 * 匹配出现零次或多次的字符。 正则表达式默认是贪婪匹配，/t[a-z]*i/ 应用于字符串 \u0026quot;titanic\u0026quot; 返回为 [\u0026quot;titani\u0026quot;]，/t[a-z]*?i/ 懒惰匹配返回 [\u0026quot;ti\u0026quot;]。 ^ 与 $ 寻找开头结尾。 \\w 等同于[A-Za-z0-9_]，\\W 相反匹配。 \\d 等同于元字符 [0-9]，\\D等同于字符串 [^0-9]。 /\\d{n,}/ 至少 n 位。 \\s 匹配空格、回车符、制表符、换页符和换行符，类似于元字符 [ \\r\\t\\f\\n\\v]，\\S 搜寻非空白字符。 ? 前的元素是可选的。 正向先行断言 (?=...)中 ... 是需要存在但不会被匹配的部分，负向先行断言 (?!...)，其中 ... 不存在则返回匹配模式的其余部分。 () 检查字符组。 捕获组 /^(\\d+)\\s\\1\\s\\1$/ 匹配一个只由相同的数字重复三次组成的由空格分隔字符串。 .replace(regex, (string | function))，可以使用 $ 访问替换字符串中的捕获组。    构造函数 Constructors 函数名首字母大写，使用 this 关键字来给它将创建的这个对象设置新的属性\n  prototype 定义原型属性，可以在所有实例之间共享，可以设置为一个对象但要定义一个 constructor 属性；原型链最顶层的 Object 定义的 hasOwnProperty() 方法只认自身属性；Object.create(obj) 创建了一个新对象，并指定了 obj 作为新对象的 prototype\n  对于不相关的对象，使用 mixin 添加共同行为\n  使属性私有化最简单的方法就是在构造函数中创建变量\n  立即调用函数表达（IIFE）：(function () {console.log(\u0026quot;Chirp, chirp!\u0026quot;);} ());，构造一个函数作用域，防止污染全局变量\n  函数柯里化（Currying）：把接受多个 arity 的函数变换成接受单一 arity 的函数，即重构函数让它接收一个参数，然后返回接收下一个参数的函数，依此类推。是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function unCurried(x, y) { return x + y; } function curried(x) { return function(y) { return x + y; } } const curried = x =\u0026gt; y =\u0026gt; x + y curried(1)(2) function impartial(x, y, z) { return x + y + z; } const partialFn = impartial.bind(this, 1, 2); partialFn(10); // 13     ","date":"2022-01-15T11:46:17+08:00","image":"https://crap.hongb.in/post/basic-javascript/cover_hu07ec2463c899400e79c7f27c20c15cfd_90120_120x120_fill_q75_box_smart1.jpg","permalink":"https://crap.hongb.in/post/basic-javascript/","title":"Basic JavaScript"}]